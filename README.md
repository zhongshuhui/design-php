1.单例模式（三私一公）(Database.class)
三私：重写__clone,__construct,再设置一个私有的属性
一公：只开放一个方法

2.工厂模式(Factory.class)
替换代码中的new，新建一个工厂类创建对象 

3.注册树模式(参考Register.class)
在自动加载或特定情况下提前注册在树，需要的时候直接提取  

4.适配器模式(参考Database文件)
可以将截然不同的函数接口封装成统一的接口，需要定义一个公共接口，其他类型功能的类
实现公共接口

5.策略模式（参考Strategy）
将一组特定的行为和算法封装成类，以适应某些特定的上下文环境
实际应用举列，一个电商网站针对男性和女性用户跳转到不同的商品类目，
并且所有的广告位展示不同的广告
1.定义个公共接口，其他不同功能实现接口
2.新建一个Page类，先注册一个策略，然后执行index函数，
即可完成针对不同策略执行不同的操作
function index(){
    $this->strategy->showAd();
    $this->strategy->showCategory();
}
function setStrategy(User $user){
    $this->strategy = $user;
}

6.数据对象模式（参考DataObjectMap文件）
1.数据对象映射模式，是将对象和数据存储映射起来，对一个对象的操作会映射为对数据存储的操作
2.举例：ORM类 
定义__construct初始化数据和初始化属性
定义__destruct在类对象销毁时候更新数据到数据库

7.观察者模式（参考Watch文件）
1.当一个对象发生改变时候，依赖他的对象全部会收到通知，并自动更新
2.例子：一个场景发生后要执行一连串的更新
3.观察者模式实现低耦合，非侵入式的通知和更新机制
增加一个事件发生的抽象类，新增addObserver和notify函数，notify函数里面遍历所有的观察者，
执行其对应的update函数
定义一个事件类Event继承时间发生的抽象类，执行里面的notify函数发起通知命令
定义一个观察者接口，观察者1和观察者2统一实现观察者接口

8.原型模式
首先创建一个对象原型，通过对其克隆生成一个新对象

9.装饰器模式（参考Decorator，添加装饰器在Canvas类中）
1.装饰器模式可以动态修改类的功能
2.使用装饰器模式，只需要运行时添加一个装饰器对象即可实现
主要的方法是在需要添加装饰器的类中添加一个装饰器的函数addDecorator，再增加一个操作装饰器具体
操作的函数beforeDraw，在beforeDraw函数中对所有装饰器遍历调用具体的方法










